<!DOCTYPE html>
<html lang="en">
<head>
  <title>Azul GUI Framework</title>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta name="description" content="Cross-platform LGPL-licensed desktop GUI framework for C and Rust using the Mozilla WebRender rendering engine">
  <meta name="keywords" content="gui, rust, user interface">

  <link rel="preload" as="font" href="./fonts/SourceSerifPro-Regular.ttf" type="font/ttf">
  <link rel="preload" as="font" href="./fonts/Morris Jenson Initialen.ttf" type="font/ttf">

  <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">
  <link rel="stylesheet" type="text/css" href="./main.css">
  <!-- index.css -->
  <style>
    main .col-1 {
      float:left;
      max-width: 500px;
    }
    main header {
      margin-bottom: 30px;
    }
    main header h2 {
      margin-top: -10px;
      margin-bottom: 40px;
      font-size: 3em;
      font-weight: 100;
    }
    main header h2 .first-letter {
      display: inline-block;
      float: left;
      margin-right: 5px;
      font-family: "Morris Jenson Initialen", serif;
      font-weight: 500;
      font-size: 2.25em;
    }
    main header h3 {
      margin-top: 25px;
      font-size: 1.2rem;
      font-weight: normal;
    }
    main section .col-1 {
      float: left;
      padding-right: 25px;
    }
    body > .center > main > section > .col-1 code {
      display: block;
      max-width: 500px;
    }

    .stats {
      font-weight: bold;
      float: left;
    }
    .stats ul li {
      list-style-type: none;
    }
    .controls:after {
      clear: both;
    }
    .controls > span:first-child > button > img {
      padding-left: 10px;
    }

    .controls > span:last-child > button > img {
      padding-left: 10px;
      transform: rotate(180deg);
    }

    .controls > span > button > img {
      display: inline-block;
      vertical-align: middle;
    }
    .controls {
      overflow: hidden;
    }
    .controls > * {
      float: right;
      margin-left: 10px;
    }
    .gradient-border-wrap {
      padding: 1px;
      border-radius: 5px;
      background: radial-gradient(ellipse farthest-corner at right bottom,#fedb37 0,#fdb931 8%,#9f7928 30%,#8a6e2f 40%,transparent 80%),
                  radial-gradient(ellipse farthest-corner at left top,#fff 0,#ffffac 8%,#d1b464 25%,#5d4a1f 62.5%,#5d4a1f 100%);
    }
    .controls .gradient-border-wrap button {
      background: #333;
      color: #eee;
      cursor: pointer;
      font-size: 1.2em;
      padding: 10px;
      appearance: none;
      -webkit-appearance: none;
      border: none;
      border-radius: 5px;
    }
    .description {
      clear: both;
      margin-top: 20px;
      font-size: 1.2em;
    }

    .feature > img {
      max-width: 100%;
      margin-bottom: 10px;
      height: auto;
    }

    body > .center > main > .code-container {
      display: inline-block;
      max-width: none;
      margin-left: 0px;
      width: 100%;
    }

    body > .center > main > .code-container > .select-language > button.active {
      background: #0084ff;
      color: white;
    }
    body > .center > main > .code-container > .select-language > button {
      font-size: 16px;
      border: none;
      padding: 5px 15px;
      margin-right: 5px;
      cursor:pointer;
      font-weight: bold;
      font-family: monospace;
    }

    body > .center > main > .code-container > code {
      display: block;
      padding: 10px;
    }
    @media screen and (min-width: 720px) {
      body > .center > main > .code-container > code {
        min-width: 500px;
      }
    }
    @media screen and (max-width: 1418px) {
      body > .center > main > .code-container {
        margin-top: 20px;
      }
    }
    @media screen and (min-width: 1418px) {
      body > .center > main > .code-container {
        max-width: 560px;
        margin-left: 40px;
        margin-top: 0px;
      }
    }
    @media screen and (max-width: 720px) {
      body > .center > main > .code-container > code {
        min-width: none;
      }
      body > .center > main > section > .col-2 {
        max-width: none;
        float: none;
        margin-bottom: 0px;
      }
      body > .center > main > section > .col-1 {
        float: none;
        padding-right: 0px;
        margin-right: 0px;
        margin-bottom: 20px;
      }
      body > .center > aside {
        float: none;
        position: static !important;
      }
      body main .col-1 header h2 {
        font-size: 30px;
        margin-bottom: 0px;
      }
      .feature {
        float:none;
        margin-bottom: 50px;
      }
    }
  </style>
</head>

<body>
  <div class="center">
  <aside>
    <header>
      <h1 style="display:none;">Azul GUI Framework</h1>
      <img src="./logo.svg">
    </header>
    <nav>
      <ul>
        <li class="active"><a href="$$ROOT_RELATIVE$$">overview</a></li>
        <li><a href="$$ROOT_RELATIVE$$/releases">releases</a></li>
        <li><a href="https://github.com/maps4print/azul">code</a></li>
        <li><a href="https://matrix.to/#/#azul:matrix.org">chat</a></li>
        <li><a href="$$ROOT_RELATIVE$$/guide">guide</a></li>
        <li><a href="$$ROOT_RELATIVE$$/api">api</a></li>
      </ul>
    </nav>
  </aside>
  <main>
    <div class="col-1">
      <header>
        <h2><span class="first-letter">B</span>uilt for beauty<br/>and speed</h2>
        <h3>Cross-platform LGPL-licensed desktop GUI framework for C and Rust, backed by the Mozilla WebRender rendering engine.</h3>
      </header>
      <section class="feature">
        <img class="showcase" id="showcase-image" src="https://azul.rs/images/helloworld.png" alt="Rendering a simple UI using the Azul GUI toolkit">
        <div>
          <div class="stats">
            <ul>
              <li id="showcase-stats-memory">Memory: 23MB</li>
              <li id="showcase-stats-cpu">CPU: 0%</li>
            </ul>
          </div>
          <div class="controls">
            <span class="gradient-border-wrap">
              <button onclick="next()">Next<img src="./images/fleur-de-lis.svg"/></button>
            </span>
            <span class="gradient-border-wrap">
              <button onclick="previous()"><img src="./images/fleur-de-lis.svg"/>Previous</button>
            </span>
          </div>
          <div class="description">
            <p id="showcase-description">The UI structure is created via composition instead of inheritance.                Callbacks can modify the application data and then tell the framework to                reconstruct the entire UI again - but only if it's necessary, not on every frame.</p>
          </div>
        </div>
      </section>
    </div>
    <div class="code-container">
      <div class="select-language">
        <button id="select-language-python" class="select-language-btn active" onclick="select_python_code()">Python</button>
        <button id="select-language-cpp" class="select-language-btn" onclick="select_cpp_code()">C++</button>
        <button id="select-language-rust" class="select-language-btn" onclick="select_rust_code()">Rust</button>
        <button id="select-language-c" class="select-language-btn" onclick="select_c_code()">C</button>
      </div>
      <code class="language-c" id="code">from azul import *<br/><br/>css = &quot;&quot;&quot;<br/>    .__azul-native-label { font-size: 50px; }<br/>&quot;&quot;&quot;<br/><br/>class DataModel:<br/>    def __init__(self, counter):<br/>        self.counter = counter<br/><br/># model -&gt; view<br/>def myLayoutFunc(data, info):<br/>    label = Label.new(&quot;{}&quot;.format(data.counter))<br/>    button = Button.new(&quot;Update counter&quot;)<br/>        .withOnClick(data, myOnClick)<br/><br/>    return Dom.body()<br/>        .withChild(label.dom())<br/>        .withChild(button.dom())<br/>        .style(Css.fromString(css))<br/><br/># model &lt;- view<br/>def myOnClick(data, info):<br/>    data.counter += 1;<br/><br/>    # tell azul to call the myLayoutFunc again<br/>    return Update.RefreshDom()<br/><br/>def main():<br/>    model = DataModel(5)<br/>    app = App.new(model, AppConfig.default())<br/>    app.run(WindowCreateOptions.default())<br/><br/>main()</code>
    </div>
  </main>
  </div>
  <script async type="text/javascript" src="./prism_code_highlighter.js"></script>
  <script type="text/javascript" async>
    var examples = [
      [{"id": "helloworld", "description": "The UI structure is created via composition instead of inheritance.                Callbacks can modify the application data and then tell the framework to                reconstruct the entire UI again - but only if it's necessary, not on every frame.", "screenshot_path": "C:\\Users\\Felix Sch\u00fctt\\Development\\azul/examples/assets/screenshots/helloworld.png", "screenshot_url": "https://azul.rs/images/helloworld.png", "cpu": "CPU: 0%", "memory": "Memory: 23MB", "image_alt": "Rendering a simple UI using the Azul GUI toolkit", "code:c": "#include &lt;azul.h&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>typedef struct {<br/>    uint32_t counter;<br/>} MyDataModel;<br/><br/>void DataModel_delete(MyDataModel* restrict A) { }<br/>AZ_REFLECT(MyDataModel, MyDataModel_delete);<br/><br/>AzString css = AzString_fromConstStr(&quot;<br/>    .__azul-native-label { font-size: 50px; }<br/>&quot;);<br/><br/>// model -&gt; view<br/>AzStyledDom myLayoutFunc(AzRefAny* restrict data, AzLayoutInfo info) {<br/>    MyDataModelRef d = MyDataModelRef_create(data);<br/>    if !(DataModel_downcastRef(data, &d)) {<br/>        return AzStyledDom_empty(); // error<br/>    }<br/><br/>    char buffer [20];<br/>    int written = snprintf(buffer, 20, &quot;%d&quot;, d-&gt;counter);<br/><br/>    AzString const labelstring = AzString_copyFromBytes(&buffer, 0, written);<br/>    AzLabel const label = AzLabel_new(labelstring);<br/><br/>    AzString const buttonstring = AzString_fromConstStr(&quot;Increase counter&quot;);<br/>    AzButton button = AzButton_new(buttonstring, AzRefAny_clone(data));<br/>    AzButton_setOnClick(&button, myOnClick);<br/><br/>    AzDom body = AzDom_body();<br/>    AzDom_addChild(&body, AzLabel_dom(label));<br/>    AzDom_addChild(&body, AzButton_dom(button));<br/><br/>    MyDataModelRef_delete(&d);<br/><br/>    return AzStyledDom_new(html, AzCss_fromString(css));<br/>}<br/><br/>// model &lt;- view<br/>AzUpdate myOnClick(AzRefAny* restrict data, AzCallbackInfo info) {<br/>    MyDataModelRefMut d = MyDataModelRefMut_create(data);<br/>    if !(DataModel_downcastRefMut(data, &d)) {<br/>        return AzUpdate_DoNothing; // error<br/>    }<br/>    // increase counter<br/>    d-&gt;counter += 1;<br/>    MyDataModelRefMut_delete(&d);<br/><br/>    // tell azul to call the myLayoutFunc again<br/>    return AzUpdate_RefreshDom;<br/>}<br/><br/>int main() {<br/>    MyDataModel model = { .counter = 5 };<br/>    AzRefAny upcasted = MyDataModel_upcast(model);<br/>    AzApp app = AzApp_new(upcasted, AzAppConfig_default());<br/>    AzApp_run(app, AzWindowCreateOptions_new(myLayoutFunc));<br/>    return 0;<br/>}", "code:cpp": "#include &lt;azul.h&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>struct MyDataModel {<br/>    uint32_t counter;<br/>};<br/><br/>static css = String::fromConstStr(<br/>    &quot;.__azul-native-label { font-size: 50px; }&quot;<br/>);<br/><br/>// model -&gt; view<br/>StyledDom myLayoutFunc(RefAny* restrict data, LayoutInfo info) {<br/>    auto d = data.createRef::&lt;MyDataModel&gt;(data);<br/>    if !data.downcastRef(data, &d) {<br/>        return StyledDom::empty(); // error<br/>    }<br/><br/>    char buffer [20];<br/>    int written = snprintf(buffer, 20, &quot;%d&quot;, d-&gt;counter);<br/><br/>    auto const labelstring = String::copyFromBytes(&buffer, 0, written);<br/>    auto const label = Label::new(labelstring);<br/><br/>    auto const buttonstring = String::fromConstStr(&quot;Increase counter&quot;);<br/>    auto const button = Button::new(buttonstring)<br/>        .withOnClick(myOnClick, data.clone());<br/><br/>    return Dom::body()<br/>        .withChild(label.dom())<br/>        .withChild(button.dom())<br/>        .style(Css::fromString(css));<br/>}<br/><br/>Update myOnClick(RefAny* restrict data, CallbackInfo info) {<br/>    auto d = data.createRefMut::&lt;MyDataModel&gt;(data);<br/>    if !data.downcastRefMut(data, &d) {<br/>        return Update::DoNothing; // error<br/>    }<br/><br/>    d-&gt;counter += 1; // increase counter<br/><br/>    // tell azul to call the myLayoutFunc again<br/>    return Update::RefreshDom;<br/>}<br/><br/>int main() {<br/>    MyDataModel model = { .counter = 5 };<br/>    AzApp app = App_new(RefAny::new(model), AppConfig_default());<br/>    app.run(WindowCreateOptions::new(myLayoutFunc));<br/>    return 0;<br/>}", "code:rust": "use azul::*;<br/><br/>struct DataModel {<br/>    counter: usize,<br/>}<br/><br/>static CSS: AzString = AzString::from_const_str(&quot;<br/>    .__azul-native-label { font-size: 50px; }<br/>&quot;);<br/><br/>extern &quot;C&quot; fn myLayoutFunc(data: &mut RefAny, _: LayoutCallbackInfo) -&gt; StyledDom {<br/><br/>    let data = match data.downcast_ref::&lt;DataModel&gt;() {<br/>        Some(s) =&gt; d,<br/>        None =&gt; return StyledDom::default(),<br/>    };<br/><br/>    let label = Label::new(format!(&quot;{}&quot;, data.counter));<br/>    let button = Button::new(&quot;Update counter&quot;)<br/>        .with_on_click(data.clone(), myOnClick);<br/><br/>    Dom::body()<br/>    .with_child(label.dom())<br/>    .with_child(button.dom())<br/>    .style(Css::from_string(CSS))<br/>}<br/><br/>extern &quot;C&quot; fn myOnClick(data: &mut RefAny, _: CallbackInfo) -&gt; Update {<br/>    let data = match data.downcast_mut::&lt;DataModel&gt;() {<br/>        Some(s) =&gt; s,<br/>        None =&gt; return Update::DoNothing, // error<br/>    };<br/><br/>    data.counter += 1;<br/><br/>    Update::RefreshDom<br/>}<br/><br/>fn main() {<br/>    let data = DataModel { counter: 0 };<br/>    let app = App::new(RefAny::new(data), AppConfig::default());<br/>    app.run(WindowCreateOptions::new(myLayoutFunc));<br/>}", "code:python": "from azul import *<br/><br/>css = &quot;&quot;&quot;<br/>    .__azul-native-label { font-size: 50px; }<br/>&quot;&quot;&quot;<br/><br/>class DataModel:<br/>    def __init__(self, counter):<br/>        self.counter = counter<br/><br/># model -&gt; view<br/>def myLayoutFunc(data, info):<br/>    label = Label.new(&quot;{}&quot;.format(data.counter))<br/>    button = Button.new(&quot;Update counter&quot;)<br/>        .withOnClick(data, myOnClick)<br/><br/>    return Dom.body()<br/>        .withChild(label.dom())<br/>        .withChild(button.dom())<br/>        .style(Css.fromString(css))<br/><br/># model &lt;- view<br/>def myOnClick(data, info):<br/>    data.counter += 1;<br/><br/>    # tell azul to call the myLayoutFunc again<br/>    return Update.RefreshDom()<br/><br/>def main():<br/>    model = DataModel(5)<br/>    app = App.new(model, AppConfig.default())<br/>    app.run(WindowCreateOptions.default())<br/><br/>main()"}, {"id": "table", "description": "Azul supports lazy loading and can render infinitely large datasets                (such as a table, shown here) while using a comparably small amount of memory.                DOM nodes share their CSS style efficiently via pointers,                so that properties do not get duplicated in memory.", "screenshot_path": "C:\\Users\\Felix Sch\u00fctt\\Development\\azul/examples/assets/screenshots/table.png", "screenshot_url": "https://azul.rs/images/table.png", "cpu": "CPU: 0%", "memory": "Memory: 23MB", "image_alt": "Rendering a table using the Azul GUI toolkit", "code:c": "#include &lt;azul.h&gt;<br/>#include &lt;azul-widgets.h&gt;<br/><br/>int main() { return 0; }", "code:cpp": "#include &lt;azul.h&gt;<br/><br/>int main() {<br/>    return 0;<br/>}", "code:rust": "#![cfg_attr(not(debug_assertions), windows_subsystem = &quot;windows&quot;)]<br/><br/>use azul::prelude::*;<br/>use azul_widgets::table_view::*;<br/>use azul::style::StyledDom;<br/><br/>struct TableDemo {<br/>    // cells: BTreeMap&lt;TableCell, String&gt;,<br/>}<br/><br/>extern &quot;C&quot; fn layout(data: &mut RefAny, _: LayoutCallbackInfo) -&gt; StyledDom {<br/><br/>    let mut table_view_state = TableViewState::default();<br/>    table_view_state.set_cell_content(TableCellIndex { row: 2, column: 2 }, &quot;Hello World&quot;);<br/>    table_view_state.set_selection(Some(TableCellSelection::from(3, 4).to(3, 4)));<br/><br/>    TableView::new(table_view_state).dom().style(Css::empty())<br/>}<br/><br/>fn main() {<br/>    let app = App::new(RefAny::new(TableDemo { }), AppConfig::default());<br/>    app.run(WindowCreateOptions::new(layout));<br/>}<br/>", "code:python": "from azul import *<br/><br/>def main():<br/>    pass"}, {"id": "svg", "description": "Azul contains a SVG1.1 compatible SVG renderer as well as functions                for tesselating and drawing shapes to OpenGL textures. Images / textures                can be composited as clip masks and even be animated.", "screenshot_path": "C:\\Users\\Felix Sch\u00fctt\\Development\\azul/examples/assets/screenshots/svg.png", "screenshot_url": "https://azul.rs/images/svg.png", "cpu": "CPU: 0%", "memory": "Memory: 23MB", "image_alt": "Rendering a SVG file using the Azul GUI toolkit", "code:c": "", "code:cpp": "#include &lt;azul.h&gt;<br/><br/>int main() {<br/>    return 0;<br/>}", "code:rust": "#![cfg_attr(not(debug_assertions), windows_subsystem = &quot;windows&quot;)]<br/><br/>extern crate azul;<br/><br/>use azul::{<br/>    prelude::*,<br/>    widgets::{button::Button, svg::*},<br/>};<br/><br/>const CSS: &str = &quot;<br/>#svg-container {<br/>    width: 100%;<br/>    height: 100%;<br/>}<br/><br/>.control-btn {<br/>    width: 20px;<br/>    height: 20px;<br/>    position: absolute;<br/>    text-align: center;<br/>    flex-direction: column;<br/>    justify-content: center;<br/>    align-items: center;<br/>    box-sizing: border-box;<br/>}<br/><br/>#btn-zoom-in {<br/>    top: 30px;<br/>    left: 30px;<br/>}<br/><br/>#btn-zoom-out {<br/>    top: 30px;<br/>    left: 70px;<br/>}<br/><br/>#btn-move-up {<br/>    top: 70px;<br/>    left: 50px;<br/>}<br/><br/>#btn-move-right {<br/>    top: 90px;<br/>    left: 70px;<br/>}<br/><br/>#btn-move-left {<br/>    top: 90px;<br/>    left: 30px;<br/>}<br/><br/>#btn-move-down {<br/>    top: 110px;<br/>    left: 50px;<br/>}<br/>&quot;;<br/><br/>const SVG: &str = include_str!(concat!(env!(&quot;CARGO_MANIFEST_DIR&quot;), &quot;/../../assets/svg/tiger.svg&quot;));<br/><br/>#[derive(Debug)]<br/>struct MyAppData {<br/>    svg: Ref&lt;SvgDocument&gt;,<br/>}<br/><br/>#[derive(Debug)]<br/>struct SvgDocument {<br/>    cache: SvgCache,<br/>    layers: Vec&lt;(SvgLayerId, SvgStyle)&gt;,<br/>    zoom: f32,<br/>    pan_horz: f32,<br/>    pan_vert: f32,<br/>}<br/><br/>type CbInfo&lt;'a&gt; = CallbackInfo&lt;'a, MyAppData&gt;;<br/><br/>impl Layout for MyAppData {<br/>    fn layout(&self, _info: LayoutInfo) -&gt; Dom&lt;MyAppData&gt; {<br/>        Dom::gl_texture(draw_svg, self.svg.clone())<br/>        .with_callback(On::Scroll, scroll_map_contents).with_id(&quot;svg-container&quot;)<br/>            .with_child(render_control_btn(&quot;+&quot;, &quot;btn-zoom-in&quot;,    |info: CbInfo| { info.state.svg.borrow_mut().zoom *= 2.0; Redraw }))<br/>            .with_child(render_control_btn(&quot;-&quot;, &quot;btn-zoom-out&quot;,   |info: CbInfo| { info.state.svg.borrow_mut().zoom /= 2.0; Redraw }))<br/>            .with_child(render_control_btn(&quot;^&quot;, &quot;btn-move-up&quot;,    |info: CbInfo| { info.state.svg.borrow_mut().pan_vert += 100.0; Redraw }))<br/>            .with_child(render_control_btn(&quot;&gt;&quot;, &quot;btn-move-right&quot;, |info: CbInfo| { info.state.svg.borrow_mut().pan_horz += 100.0; Redraw }))<br/>            .with_child(render_control_btn(&quot;&lt;&quot;, &quot;btn-move-left&quot;,  |info: CbInfo| { info.state.svg.borrow_mut().pan_horz -= 100.0; Redraw }))<br/>            .with_child(render_control_btn(&quot;v&quot;, &quot;btn-move-down&quot;,  |info: CbInfo| { info.state.svg.borrow_mut().pan_vert -= 100.0; Redraw }))<br/>    }<br/>}<br/><br/>fn render_control_btn(label: &'static str, css_id: &'static str, callback: fn(CbInfo) -&gt; UpdateScreen) -&gt; Dom&lt;MyAppData&gt; {<br/>    Button::with_label(label).dom().with_class(&quot;control-btn&quot;).with_id(css_id).with_callback(On::MouseUp, callback)<br/>}<br/><br/>fn draw_svg(info: GlCallbackInfo) -&gt; GlCallbackReturn {<br/><br/>    use azul::widgets::svg::SvgLayerResource::*;<br/><br/>    let state = info.state.downcast::&lt;SvgDocument&gt;()?;<br/>    let map: &SvgDocument = &state.borrow();<br/>    let logical_size = info.bounds.get_logical_size();<br/><br/>    let svg = Svg::with_layers(map.layers.iter().map(|e| Reference(*e)).collect())<br/>        .with_pan(map.pan_horz, map.pan_vert)<br/>        .with_zoom(map.zoom)<br/>        .render_svg(<br/>            &map.cache,<br/>            info.layout_info.gl_context.clone(),<br/>            info.bounds.hidpi_factor,<br/>            logical_size<br/>        );<br/><br/>    Some(svg)<br/>}<br/><br/>fn scroll_map_contents(info: CbInfo) -&gt; UpdateScreen {<br/><br/>    let scroll_y = info.get_mouse_state().scroll_y?;<br/>    let keyboard_state = info.get_keyboard_state().clone();<br/>    let mut svg = info.state.svg.borrow_mut();<br/><br/>    if keyboard_state.shift_down {<br/>        svg.pan_horz += scroll_y;<br/>    } else if keyboard_state.ctrl_down {<br/>        if scroll_y.is_sign_positive() {<br/>            svg.zoom /= 2.0;<br/>        } else {<br/>            svg.zoom *= 2.0;<br/>        }<br/>    } else {<br/>        svg.pan_vert += scroll_y;<br/>    }<br/><br/>    Redraw<br/>}<br/><br/>fn main() {<br/><br/>    let mut svg_cache = SvgCache::empty();<br/>    let svg_layers = svg_cache.add_svg(&SVG).unwrap();<br/><br/>    let app_data = MyAppData {<br/>        svg: Ref::new(SvgDocument {<br/>            cache: svg_cache,<br/>            layers: svg_layers,<br/>            zoom: 1.0,<br/>            pan_horz: 0.0,<br/>            pan_vert: 0.0,<br/>        }),<br/>    };<br/><br/>    let app = App::new(app_data, AppConfig::default()).unwrap();<br/>    let css = css::override_native(include_str!(CSS_PATH!())).unwrap();<br/>    app.run(WindowCreateOptions::new(css));<br/>}<br/>", "code:python": "from azul import *<br/><br/>def main():<br/>    pass"}, {"id": "calculator", "description": "Composing larger UIs is just a matter of proper function composition.                Widget-specific data is either stored on the callback object itself -                or on the DOM node, similar to a HTML 'dataset' attribute.", "screenshot_path": "C:\\Users\\Felix Sch\u00fctt\\Development\\azul/examples/assets/screenshots/calculator.png", "screenshot_url": "https://azul.rs/images/calculator.png", "cpu": "CPU: 0%", "memory": "Memory: 23MB", "image_alt": "Composing widgets via functions in the Azul GUI toolkit", "code:c": "", "code:cpp": "#include &lt;azul.h&gt;<br/><br/>int main() {<br/>    return 0;<br/>}", "code:rust": "#![windows_subsystem = &quot;windows&quot;]<br/><br/>#[derive(Default)]<br/>pub struct Calculator {<br/>    pub current_operator: Option&lt;OperandStack&gt;,<br/>    pub current_operand_stack: OperandStack,<br/>    pub division_by_zero: bool,<br/>    pub expression: String,<br/>    pub last_event: Option&lt;Event&gt;,<br/>}<br/><br/>#[derive(Clone, Debug)]<br/>pub enum Event {<br/>    Clear,<br/>    InvertSign,<br/>    Percent,<br/>    Divide,<br/>    Multiply,<br/>    Subtract,<br/>    Plus,<br/>    EqualSign,<br/>    Dot,<br/>    Number(u8),<br/>}<br/><br/>pub mod resources {<br/>    macro_rules! FONT_PATH {() =&gt; { concat!(env!(&quot;CARGO_MANIFEST_DIR&quot;), &quot;/examples/assets/fonts/KoHo-Light.ttf&quot;)};}<br/><br/>    static FONT: &[u8] = include_bytes!(FONT_PATH!());<br/>    static CSS: &str = &quot;<br/>        * {<br/>            font-size: 27px;<br/>            font-family: \\&quot;KoHo-Light\\&quot;;<br/>            flex-direction: column;<br/>            box-sizing: border-box;<br/>            flex-grow: 1;<br/>        }<br/><br/>        #expression {<br/>            max-height: 50pt;<br/>            background-color: #444;<br/>            color: white;<br/>            flex-direction: row;<br/>            text-align: right;<br/>            padding-right: 40pt;<br/>            justify-content: flex-end;<br/>        }<br/><br/>        #result {<br/>            max-height: 81pt;<br/>            background: linear-gradient(to top, #111, #444);<br/>            color: white;<br/>            flex-direction: row;<br/>            text-align: right;<br/>            padding-right: 16pt;<br/>            justify-content: flex-end;<br/>            font-size: 60px;<br/>        }<br/><br/>        #numpad-container {<br/>            background-color: #d6d6d6;<br/>        }<br/><br/>        .numpad-button {<br/>            border-right: 1px solid #8d8d8d;<br/>        }<br/><br/>        .row {<br/>            flex-direction: row;<br/>            border-bottom: 1px solid #8d8d8d;<br/>            height: 78px;<br/>        }<br/><br/>        .orange {<br/>            background: linear-gradient(to bottom, #f69135, #f37335);<br/>            color: white;<br/>            border-bottom: 1px solid #8d8d8d;<br/>            width: 98px;<br/>        }<br/><br/>        .orange:focus {<br/>            border: 3px solid blue;<br/>        }<br/><br/>        #zero {<br/>            flex-grow: 2;<br/>            border-bottom: none;<br/>        }<br/>    &quot;;<br/>}<br/><br/>/// Handles UI rendering and callback definition<br/>pub mod ui {<br/><br/>    pub extern &quot;C&quot; fn layout(data: &mut RefAny, _info: LayoutCallbackInfo) -&gt; StyledDom {<br/><br/>        let result = if self.division_by_zero {<br/>            format!(&quot;Cannot divide by zero.&quot;)<br/>        } else {<br/>            self.current_operand_stack.get_display()<br/>        };<br/><br/>        Dom::div()<br/>            .with_child(Dom::label(self.expression.to_string()).with_id(&quot;expression&quot;))<br/>            .with_child(Dom::label(result).with_id(&quot;result&quot;))<br/>            .with_child(<br/>                Dom::div()<br/>                    .with_id(&quot;numpad-container&quot;)<br/>                    .with_child(render_row([&quot;C&quot;, &quot;+/-&quot;, &quot;%&quot;, &quot;/&quot;]))<br/>                    .with_child(render_row([&quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;x&quot;]))<br/>                    .with_child(render_row([&quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;-&quot;]))<br/>                    .with_child(render_row([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;+&quot;]))<br/>                    .with_child(<br/>                        Dom::div()<br/>                            .with_class(&quot;row&quot;)<br/>                            .with_child(numpad_btn(&quot;0&quot;, &quot;numpad-button&quot;).with_id(&quot;zero&quot;))<br/>                            .with_child(numpad_btn(&quot;.&quot;, &quot;numpad-button&quot;))<br/>                            .with_child(numpad_btn(&quot;=&quot;, &quot;orange&quot;)),<br/>                    ),<br/>            )<br/>            .with_callback(EventFilter::Window(WindowEventFilter::TextInput), handle_text_input)<br/>            .with_callback(EventFilter::Window(WindowEventFilter::VirtualKeyDown), handle_virtual_key_input)<br/>    }<br/><br/>    #[inline]<br/>    fn render_row(labels: [&'static str; 4]) -&gt; StyledDom {<br/>        Dom::div()<br/>            .with_class(&quot;row&quot;)<br/>            .with_child(numpad_btn(labels[0], &quot;numpad-button&quot;))<br/>            .with_child(numpad_btn(labels[1], &quot;numpad-button&quot;))<br/>            .with_child(numpad_btn(labels[2], &quot;numpad-button&quot;))<br/>            .with_child(numpad_btn(labels[3], &quot;orange&quot;))<br/>    }<br/><br/>    #[inline]<br/>    fn numpad_btn(label: &'static str, class: &'static str) -&gt; StyledDom {<br/>        Dom::label(label)<br/>            .with_class(class)<br/>            .with_tab_index(TabIndex::Auto)<br/>            .with_callback(On::MouseUp, handle_mouseclick_numpad_btn)<br/>    }<br/><br/>    extern &quot;C&quot; fn handle_mouseclick_numpad_btn(data: &mut RefAny, info: CallbackInfo) -&gt; UpdateScreen {<br/><br/>        // Figure out which row and column was clicked...<br/>        let (clicked_col_idx, clicked_row_idx) = {<br/>            let mut row_iter = info.parent_nodes();<br/>            row_iter.next()?;<br/>            (info.target_index_in_parent()?, row_iter.current_index_in_parent()?)<br/>        };<br/><br/>        // Figure out what button was clicked from the given row and column, filter bad events<br/>        let event = match (clicked_row_idx, clicked_col_idx) {<br/>            (0, 0) =&gt; Event::Clear,<br/>            (0, 1) =&gt; Event::InvertSign,<br/>            (0, 2) =&gt; Event::Percent,<br/>            (0, 3) =&gt; Event::Divide,<br/><br/>            (1, 0) =&gt; Event::Number(7),<br/>            (1, 1) =&gt; Event::Number(8),<br/>            (1, 2) =&gt; Event::Number(9),<br/>            (1, 3) =&gt; Event::Multiply,<br/><br/>            (2, 0) =&gt; Event::Number(4),<br/>            (2, 1) =&gt; Event::Number(5),<br/>            (2, 2) =&gt; Event::Number(6),<br/>            (2, 3) =&gt; Event::Subtract,<br/><br/>            (3, 0) =&gt; Event::Number(1),<br/>            (3, 1) =&gt; Event::Number(2),<br/>            (3, 2) =&gt; Event::Number(3),<br/>            (3, 3) =&gt; Event::Plus,<br/><br/>            (4, 0) =&gt; Event::Number(0),<br/>            (4, 1) =&gt; Event::Dot,<br/>            (4, 2) =&gt; Event::EqualSign,<br/><br/>            _ =&gt; return DontRedraw, // invalid item<br/>        };<br/><br/>        println!(&quot;Got event via mouse input: {:?}&quot;, event);<br/>        process_event(info.state, event)<br/>    }<br/><br/>    extern &quot;C&quot; fn handle_text_input(data: &mut RefAny, info: CallbackInfo) -&gt; UpdateScreen {<br/>        let current_key = info.get_keyboard_state().current_char?;<br/>        let event = match current_key {<br/>            '0' =&gt; Event::Number(0),<br/>            '1' =&gt; Event::Number(1),<br/>            '2' =&gt; Event::Number(2),<br/>            '3' =&gt; Event::Number(3),<br/>            '4' =&gt; Event::Number(4),<br/>            '5' =&gt; Event::Number(5),<br/>            '6' =&gt; Event::Number(6),<br/>            '7' =&gt; Event::Number(7),<br/>            '8' =&gt; Event::Number(8),<br/>            '9' =&gt; Event::Number(9),<br/>            '*' =&gt; Event::Multiply,<br/>            '-' =&gt; Event::Subtract,<br/>            '+' =&gt; Event::Plus,<br/>            '/' =&gt; Event::Divide,<br/>            '%' =&gt; Event::Percent,<br/>            '.' | ',' =&gt; Event::Dot,<br/>            _ =&gt; return DontRedraw,<br/>        };<br/><br/>        println!(&quot;Got event via keyboard input: {:?}&quot;, event);<br/>        process_event(info.state, event)<br/>    }<br/><br/>    extern &quot;C&quot; fn handle_virtual_key_input(data: &mut RefAny, info: CallbackInfo) -&gt; UpdateScreen {<br/>        let current_key = info.get_keyboard_state().current_virtual_keycode?;<br/>        let event = match current_key {<br/>            VirtualKeyCode::Return =&gt; Event::EqualSign,<br/>            VirtualKeyCode::Back =&gt; Event::Clear,<br/>            _ =&gt; return DontRedraw,<br/>        };<br/>        process_event(info.state, event)<br/>    }<br/>}<br/><br/>/// Handles the application logic<br/>pub mod logic {<br/><br/>    #[derive(Debug, Clone, Default)]<br/>    pub struct OperandStack {<br/>        pub stack: Vec&lt;Number&gt;,<br/>        pub negative_number: bool,<br/>    }<br/><br/>    #[derive(Debug, Copy, Clone, PartialEq, Eq)]<br/>    enum Number {<br/>        Value(u8),<br/>        Dot,<br/>    }<br/><br/>    impl OperandStack {<br/>        /// Returns the displayable string, i.e for:<br/>        /// `[3, 4, Dot, 5]` =&gt; `&quot;34.5&quot;`<br/>        pub fn get_display(&self) -&gt; String {<br/>            let mut display_string = String::new();<br/><br/>            if self.negative_number {<br/>                display_string.push('-');<br/>            }<br/><br/>            if self.stack.is_empty() {<br/>                display_string.push('0');<br/>            } else {<br/>                // If we get a dot at the end of the stack, i.e. &quot;35.&quot; - store it,<br/>                // but don't display it<br/>                let mut first_dot_found = false;<br/>                for num in &self.stack {<br/>                    match num {<br/>                        Number::Value(v) =&gt; display_string.push((v + 48) as char),<br/>                        Number::Dot =&gt; {<br/>                            if !first_dot_found {<br/>                                display_string.push('.');<br/>                                first_dot_found = true;<br/>                            }<br/>                        }<br/>                    }<br/>                }<br/>            }<br/><br/>            display_string<br/>        }<br/><br/>        /// Returns the number which you can use to calculate things with<br/>        pub fn get_number(&self) -&gt; f32 {<br/>            let stack_size = self.stack.len();<br/>            if stack_size == 0 {<br/>                return 0.0;<br/>            }<br/><br/>            // Iterate the stack until the first Dot is found<br/>            let first_dot_position = self.stack.iter()<br/>                .position(|x| *x == Number::Dot)<br/>                .and_then(|x| Some(x - 1))<br/>                .unwrap_or(stack_size - 1) as i32;<br/><br/>            let mut final_number = 0.0;<br/><br/>            for (number_position, number) in self.stack.iter().filter_map(|x| match x {<br/>                    Number::Dot =&gt; None,<br/>                    Number::Value(v) =&gt; Some(v),<br/>                })<br/>                .enumerate()<br/>            {<br/>                // i.e. the 5 in 5432.1 has a distance of 3 to the first dot (meaning 3 zeros)<br/>                let diff_to_first_dot = first_dot_position - number_position as i32;<br/>                final_number += (*number as f32) * 10.0_f32.powi(diff_to_first_dot);<br/>            }<br/><br/>            if self.negative_number {<br/>                final_number = -final_number;<br/>            }<br/>            final_number<br/>        }<br/><br/>        fn from_f32(value: f32) -&gt; Self {<br/>            let mut result = OperandStack::default();<br/>            for c in value.to_string().chars() {<br/>                if c == '-' {<br/>                    result.negative_number = true;<br/>                } else if c == '.' {<br/>                    result.stack.push(Number::Dot);<br/>                } else {<br/>                    result.stack.push(Number::Value((c as u8 - 48) as u8))<br/>                }<br/>            }<br/>            result<br/>        }<br/>    }<br/><br/>    impl Calculator {<br/><br/>        /// Act on the event accordingly<br/>        fn process_event(&mut self, event: Event) -&gt; UpdateScreen {<br/>            match event {<br/>                Event::Clear =&gt; {<br/>                    *calculator = Calculator::default();<br/>                    Redraw<br/>                }<br/>                Event::InvertSign =&gt; {<br/>                    if !calculator.division_by_zero {<br/>                        calculator.current_operand_stack.negative_number = !calculator.current_operand_stack.negative_number;<br/>                    }<br/>                    Redraw<br/>                }<br/>                Event::Percent =&gt; {<br/><br/>                    if calculator.division_by_zero {<br/>                        return DontRedraw;<br/>                    }<br/><br/>                    if let Some(operation) = &calculator.last_event.clone() {<br/>                        if let Some(operand) = calculator.current_operator.clone() {<br/>                            let num = calculator.current_operand_stack.get_number();<br/>                            let op = operand.get_number();<br/>                            let result = match operation {<br/>                                Event::Plus | Event::Subtract =&gt; op / 100.0 * num,<br/>                                Event::Multiply | Event::Divide =&gt; num / 100.0,<br/>                                _ =&gt; unreachable!(),<br/>                            };<br/>                            calculator.current_operand_stack = OperandStack::from(result);<br/>                        }<br/>                    }<br/><br/>                    Redraw<br/>                }<br/>                Event::EqualSign =&gt; {<br/><br/>                    if calculator.division_by_zero {<br/>                        return DontRedraw;<br/>                    }<br/><br/>                    if let Some(Event::EqualSign) = calculator.last_event {<br/>                        calculator.expression = format!(&quot;{} =&quot;, calculator.current_operand_stack.get_display());<br/>                    } else {<br/>                        calculator.expression.push_str(&format!(&quot;{} =&quot;, calculator.current_operand_stack.get_display()));<br/>                        if let Some(operation) = &calculator.last_event.clone() {<br/>                            if let Some(operand) = calculator.current_operator.clone() {<br/>                                let num = calculator.current_operand_stack.get_number();<br/>                                let op = operand.get_number();<br/>                                match perform_operation(op, &operation, num) {<br/>                                    Some(r) =&gt; calculator.current_operand_stack = OperandStack::from(r),<br/>                                    None =&gt; calculator.division_by_zero = true,<br/>                                }<br/>                            }<br/>                        }<br/>                    }<br/><br/>                    calculator.current_operator = None;<br/>                    calculator.last_event = Some(Event::EqualSign);<br/><br/>                    Redraw<br/>                }<br/>                Event::Dot =&gt; {<br/><br/>                    if calculator.division_by_zero {<br/>                        return DontRedraw;<br/>                    }<br/><br/>                    if calculator.current_operand_stack.stack.iter().position(|x| *x == Number::Dot).is_none() {<br/>                        if calculator.current_operand_stack.stack.len() == 0 {<br/>                            calculator.current_operand_stack.stack.push(Number::Value(0));<br/>                        }<br/>                        calculator.current_operand_stack.stack.push(Number::Dot);<br/>                    }<br/><br/>                    Redraw<br/>                }<br/>                Event::Number(v) =&gt; {<br/>                    if let Some(Event::EqualSign) = calculator.last_event {<br/>                        *calculator = Calculator::default();<br/>                    }<br/>                    calculator.current_operand_stack.stack.push(Number::Value(v));<br/>                    Redraw<br/>                }<br/>                operation =&gt; {<br/><br/>                    if calculator.division_by_zero {<br/>                        return DontRedraw;<br/>                    }<br/><br/>                    if let Some(Event::EqualSign) = calculator.last_event {<br/>                        calculator.expression = String::new();<br/>                    }<br/><br/>                    calculator.expression.push_str(&calculator.current_operand_stack.get_display());<br/><br/>                    if let Some(Event::EqualSign) = calculator.last_event {<br/>                        calculator.current_operator = Some(calculator.current_operand_stack.clone());<br/>                    } else if let Some(last_operation) = &calculator.last_event.clone() {<br/>                        if let Some(operand) = calculator.current_operator.clone() {<br/>                            let num = calculator.current_operand_stack.get_number();<br/>                            let op = operand.get_number();<br/>                            match perform_operation(op, last_operation, num) {<br/>                                Some(r) =&gt; calculator.current_operator = Some(OperandStack::from(r)),<br/>                                None =&gt; calculator.division_by_zero = true,<br/>                            }<br/>                        }<br/>                    } else {<br/>                        calculator.current_operator = Some(calculator.current_operand_stack.clone());<br/>                    }<br/><br/>                    calculator.current_operand_stack = OperandStack::default();<br/>                    calculator.expression.push_str(match operation {<br/>                        Event::Plus =&gt; &quot; + &quot;,<br/>                        Event::Subtract =&gt; &quot; - &quot;,<br/>                        Event::Multiply =&gt; &quot; x &quot;,<br/>                        Event::Divide =&gt; &quot; / &quot;,<br/>                        _ =&gt; unreachable!(),<br/>                    });<br/>                    calculator.last_event = Some(operation);<br/><br/>                    Redraw<br/>                }<br/>            }<br/>        }<br/>    }<br/><br/>    impl Event {<br/>        /// Performs an arithmetic operation. Returns None when trying to divide by zero.<br/>        fn perform_operation(left_operand: f32, right_operand: f32) -&gt; Option&lt;f32&gt; {<br/>            match operation {<br/>                Event::Multiply =&gt; Some(left_operand * right_operand),<br/>                Event::Subtract =&gt; Some(left_operand - right_operand),<br/>                Event::Plus =&gt; Some(left_operand + right_operand),<br/>                Event::Divide =&gt; if right_operand == 0.0 {<br/>                        None<br/>                    }<br/>                    else {<br/>                        Some(left_operand / right_operand)<br/>                },<br/>                _ =&gt; unreachable!(),<br/>            }<br/>        }<br/>    }<br/>}<br/><br/>fn main() {<br/>    let mut app = App::new(Calculator::default(), AppConfig::default()).unwrap();<br/>    app.add_fomt(&quot;KoHo-Light&quot;, FontRef::embedded(ui::FONT));<br/>    app.run(WindowCreateOptions::new(ui::layout));<br/>}<br/>", "code:python": "from azul import *<br/><br/>def main():<br/>    pass"}, {"id": "xml", "description": "Azul contains an XML-based UI description which can be instantly                hot-reloaded from a file. After prototyping the UI in XML / CSS,                you can compile the code to a native language in order to get both                fast design iteration times as well as performant code.", "screenshot_path": "C:\\Users\\Felix Sch\u00fctt\\Development\\azul/examples/assets/screenshots/xml.png", "screenshot_url": "https://azul.rs/images/xml.png", "cpu": "Memory: 0%", "memory": "Memory: 23MB", "image_alt": "XML UI hot-reloading for fast prototyping", "code:c": "", "code:cpp": "#include &lt;azul.h&gt;<br/><br/>int main() {<br/>    return 0;<br/>}", "code:rust": "#![windows_subsystem = &quot;windows&quot;]<br/><br/>use azul::{<br/>    app::{App, AppConfig},<br/>    window::WindowCreateOptions,<br/>    style::StyledDom,<br/>    callbacks::{RefAny, LayoutCallbackInfo},<br/>};<br/><br/>#[derive(Debug)]<br/>struct Data { }<br/><br/>extern &quot;C&quot; fn layout(data: &mut RefAny, _info: LayoutCallbackInfo) -&gt; StyledDom {<br/>    StyledDom::from_file(&quot;./ui.xml&quot;.into())<br/>}<br/><br/>fn main() {<br/>    let data = RefAny::new(Data { });<br/>    let app = App::new(data, AppConfig::default());<br/>    let mut window = WindowCreateOptions::new(layout);<br/>    window.hot_reload = true;<br/>    app.run(window);<br/>}<br/>", "code:python": "from azul import *<br/><br/>def main():<br/>    pass"}]
    ];
    var current_lang = "python";
    var current_example = 0;
    var max_len = examples[0].length;

    function render_example() {
      document.getElementById("showcase-image").src = examples[0][current_example]["screenshot_url"];
      document.getElementById("showcase-image").alt = examples[0][current_example]["image_alt"];
      document.getElementById("showcase-stats-memory").innerHTML = examples[0][current_example]["memory"];
      document.getElementById("showcase-stats-cpu").innerHTML = examples[0][current_example]["cpu"];
      document.getElementById("showcase-description").innerHTML = examples[0][current_example]["description"];

      var language_buttons = document.getElementsByClassName("select-language-btn");
      for (var i = language_buttons.length - 1; i >= 0; i--) {
        language_buttons[i].classList.remove("active");
      }

      if (current_lang === "c") {
        document.getElementById("code").innerHTML = examples[0][current_example]["code:c"];
        document.getElementById("select-language-c").classList.add("active");
      } else if (current_lang === "cpp") {
        document.getElementById("code").innerHTML = examples[0][current_example]["code:cpp"];
        document.getElementById("select-language-cpp").classList.add("active");
      } else if (current_lang === "rust") {
        document.getElementById("code").innerHTML = examples[0][current_example]["code:rust"];
        document.getElementById("select-language-rust").classList.add("active");
      } else {
        document.getElementById("code").innerHTML = examples[0][current_example]["code:python"];
        document.getElementById("select-language-python").classList.add("active");
      }
    }

    function select_c_code() {
      if (current_lang === "c") {
        return;
      }
      current_lang = "c"
      render_example();
    }

    function select_cpp_code() {
      if (current_lang === "cpp") {
        return;
      }
      current_lang = "cpp"
      render_example();
    }

    function select_rust_code() {
      if (current_lang === "rust") {
        return;
      }
      current_lang = "rust"
      render_example();
    }

    function select_python_code() {
      if (current_lang === "python") {
        return;
      }
      current_lang = "python"
      render_example();
    }

    function next() {
      current_example += 1;
      if (current_example >= max_len) {
        current_example = 0;
      }
      render_example();
    }

    function previous() {
      current_example -= 1;
      if (current_example < 0) {
        current_example = max_len - 1;
      }
      render_example();
    }
  </script>
</body>
</html>
